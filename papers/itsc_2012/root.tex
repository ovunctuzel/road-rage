\documentclass[letterpaper, 10 pt, conference]{ieeeconf}  % Comment this line out
                                                          % if you need a4paper
%\documentclass[a4paper, 10pt, conference]{ieeeconf}      % Use this line for a4
                                                          % paper

\IEEEoverridecommandlockouts                              % This command is only
                                                          % needed if you want to
                                                          % use the \thanks command
\overrideIEEEmargins
% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document

\title{\LARGE \bf
TODO Name this thing
}

% TODO which style do we use for authors? and do we list all 4 of us here?

%\author{ \parbox{3 in}{\centering Huibert Kwakernaak*
%         \thanks{*Use the $\backslash$thanks command to put information here}\\
%         Faculty of Electrical Engineering, Mathematics and Computer Science\\
%         University of Twente\\
%         7500 AE Enschede, The Netherlands\\
%         {\tt\small h.kwakernaak@autsubmit.com}}
%         \hspace*{ 0.5 in}
%         \parbox{3 in}{ \centering Pradeep Misra**
%         \thanks{**The footnote marks may be inserted manually}\\
%        Department of Electrical Engineering \\
%         Wright State University\\
%         Dayton, OH 45435, USA\\
%         {\tt\small pmisra@cs.wright.edu}}
%}

\author{Huibert Kwakernaak$^{1}$ and Pradeep Misra$^{2}$% <-this % stops a space
% \thanks{$^{1}$H. Kwakernaak is with Faculty of Electrical Engineering, Mathematics and Computer Science,
%         University of Twente, 7500 AE Enschede, The Netherlands
%         {\tt\small h.kwakernaak at papercept.net}}%
% \thanks{$^{2}$P. Misra is with the Department of Electrical Engineering, Wright State University,
%         Dayton, OH 45435, USA
%         {\tt\small p.misra at ieee.org}}%
}

\long\def\commentp#1{{\bf **Peter: #1**}}
\long\def\commentpk#1{{\bf **Piyush: #1**}}
\long\def\commentm#1{{\bf **Mike: #1**}}
\long\def\commentd#1{{\bf **Dustin: #1**}}

\begin{document}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
Autonomous vehicle technology have seen great advancements in recent years and are closer to being commercially viable. Driverless cars provide opportunities for optimizing traffic across cities in ways not possible before. This paper explores such scenarios and introduces a new traffic micro-simulator named AORTA. AORTA emphasizes research using scale simulations generated from OpenStreetMap data. This paper presents parsing map through the simulator and using the AORTA simulator. It concludes with some preliminary results that demonstrate the power of this simulator.   
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{INTRODUCTION}

\commentpk{This section is still under construction. Do not review.}

% what are our goals with this paper?
% theme: easy simulation in your city, in 2 minutes!
% * demonstrate use of OSM and motivate more data collection
% * present a simulation framework
% * present a pretty naive static planning
% * motivate and demonstrate wards for hierarchial planning (but also reasoning
%    about congestion)
% be sure to emphasize open source!

% contribution: autonomous car / human car sim on EXISTING INFRASTRUCTURE

Autonomous vehicles have seen tremendous progress in recent years. The DARPA Challenge in 2004 saw the farthese distance being traversed autonomously as In 2004, no autonomous vehicle was able to complete the course set out in the first DARPA Challenge. By 2007, 5 vehicles finished the course of 130 miles in urban environments. By 2011, autonomous vehicles projects have now touched 160,000 miles and an autonomous car drove for 13,000 miles in Europe. Autonomous cars are here to stay, and this changes how traffic is dealt with in the forseeable future. The infrastructure will change to support autonomous vehicles, but it is hard to say more about our traffic demands. Will we be able to gain more roads in the future. Do we have the space to expand and will autonomous vehicles be able to reach your doorstep.

This paper presents a new methodology for micro-simulating autonomous traffic for such situations where we will continue to use existing roads for autonomous vehicles. We believe that the autonomous traffic will be controlled via an overseer. The overseer can define behaviors for indivudal agents and individual intersections. The overseer itself can be a centralized and decentralized system that is capable for making such decisions in real-time.

To implement such a methodology, we have come up with our own traffic simulator called AORTA. In AORTA we focus on the behavior of agents and intersections. Our simulator is generic enough to take advantage of implementing behaviors for cars which can represent human driving, along with standardized traffic light signals. We believe that that traffic light signals will be able to do better once we start using Autonomous Intersection Managers such as AIM.

To use road data, we can use OpenStreetMap. xml files exported using OSM are directly read by a tool and parsed to create an understandable map. Our simulator then uses this map to create the simulation and can introduce an army of agents to simulate traffic inside the simulator.

\commentpk{Needs introduction to the rest of the paper here}

Section 2 will review other traffic simulators. Section 3 will introduce the
overall architecture of AORTA. Section 4 describes how OSM maps are used.
Section 5 explains the simulation engine and the properties AORTA posses that
are useful for general traffic experiments. Section 6 gives some initial
results from such an experiment, and Section 7 concludes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{RELATED WORKS}

\commentpk{This section is still under construction. Do not review.}

A number of good micro-simulators have been created in the past decade. In this section we compare some of the similarities and differences with other such simulators.

One such 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{ARCHITECTURE}

AORTA's implementation uses Scala, a language implemented on the Java Virtual
Machine. Scala provides the advantage of functional programming constructs
without imposing them; parts of AORTA or extensions or clients can just as
easily be written in the more familiar Java.

The architecture of AORTA is described below.

thread pools?

programs: build map, UI (describe what it can do -- particularly demand
generation), headless

api / extending it
maps separate from simulation separate from UI (mostly)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{MAP CONSTRUCTION FROM OSM}

\commentd{briefly introduce OSM, advantages, etc}

To run a simulation on a map from OSM, there is a one-time conversion process to
transform the map into AORTA's format, which is also encoded with XML. It is
split into 3 passes, each feeding the next.

\subsection{Map Model}

roads, verts, edges, wards, traversables, turns...

edges are made up of multiple lines.. this could be control pts of a curve
(hereon, line means line segment)
(turns are also traversable)

\subsection{Pass 1}

The relevant parts of OSM's map model are nodes and ways. A node corresponds to
a GPS location, and ways are links between many nodes, corresponding to roads
and other paths. The first pass reads OSM's XML format, gathering ways as a
series of coordinates. Ways intersect when a node is used by multiple ways.

Since OSM also encodes pedestrian paths, bike routes, and even lakes with ways,
pass 1 filters out anything that does not seem to be driveable. OSM does not
seem to provide a unified list of valid roads, so these heuristics are
imperfect.

Finally, coordinates are normalized from GPS (longitude, latitude) to a planar
coordinate system with no negative coordinates and the Y coordinate increasing
upwards. This is done for convenince of manipulation in the UI, but the scale
and offset used are retained, so a coordinate in the final form of the map can
still be mapped back to its original GPS form.

\subsection{Pass 2}

OSM ways only implicitly intersect at common coordinates; AORTA's structure
demands a traditional definition of edge linking exactly two vertices. Pass 2
walks along each way's coordinates, dividing it into multiple undirected edges.

\subsection{Pass 3}

Finally, pass 3 performs successive transformations to produce the final graph,
which is saved in XML.

\subsubsection{Making Lanes}

Undirected edges are first multiplied into directed lanes. The coordinates from
a slice of an OSM way are interpreted to be the center line of the road, and
lanes are placed by projecting the width of a line perpendicularly from the
center line in either direction. OSM encodes one-way streets, so in this case,
if there are an odd number of one-way lanes, the middle lane is placed where the
center line would be, and the other lanes are shifted from there. If there are
an even number, then the middle two are both equidistant away from the invisible
center line. The number of lanes is guessed from OSM's annotation of the way's
``type.'' OSM's specification includes a tag for number of lanes, but in
practice as of the time of writing, it is rarely used.

\subsubsection{Making Turns}

Next, turns are constructed at each vertex between the incoming and outgoing
edges. This is completely heuristic based: we classify a potential turn as a
left, right, or straight turn based solely on angles between edges and if the
edge's original OSM ID matches. U-turns are constructed at dead-ends. If several
lanes all cross into fewer lanes, merging is forced for the rightmost lanes.
These patterns are attempts at generalizations; this process results in many
intersections having the incorrect turns. However, without a more detailed
source, this is the best compromise. Finally, the geometry of a turn is
extremely simplified as a single line between the ends of the edges it connects.
In the future, a more realistic curve could be drawn.

\subsubsection{Ensuring connectivity}

Because turns are constructed imperfectly, most large graphs have edges that are
not reachable from some portions of the graph. Simulation and pathfinding would
suffer greatly if this was the case, so pass 3 uses Tarjan's linear-time
algorithm for locating strongly connected components to remove the components of
the directed graph with the least members. (There is also a debugging switch to
leave these components in and highlight them in the UI.) The algorithm operates
at the granularity of lanes. If several lanes of many are disconnected within
one road, then the bad lanes are spliced out. This results in visually
unappealing geometric gaps, but if the entire road were removed, then Tarjan's
algorithm would have to be repeated to determine what edges the good lanes would
then disconnect. The end result is a connected digraph, ideal for corner
case-free pathfinding and simulation.

\subsubsection{Cleaning up geometry}

A road's center line correctly meets adjoining roads' center lines in the middle
of an intersection. Since the lines for a lane are parallel to the center line
and have the same length, they also meet in the intersection. This is
geometrically incorrect; lanes stop along the border of the intersection. Thus,
pass 3 includes heuristics to trim a lane's lines to the spot where they
intersect with another lane's lines. This results in a more accurate model, but
the process is imperfect, so sometimes lines extend too far or not enough.

\subsubsection{Hierarchial divisions of the graph}

\commentd{i don't think this'll have much coverage in the rest of the paper; should
 we describe wards?}

\subsection{Limitations}

proposals to change OSM to fix these issues

projecting lines sucks... but all it really does is clutter UI
filtering out invalid ways in pass 1 is really not a clear process
number of lanes... road types are wacky and wrong
turns are brittle.. detecting right-turn only lane is rare. shared center lane?
  not part of our model, or OSM's.
removing sccs is not ideal

\subsection{Integrating other data sources}

how easy would it be?

match on gps, or on road metadata like names

integrating with what other sources for spawning traffic, placing POI?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{SIMULATION}

AORTA uses microscopic simulation, modeling individual drivers as agents.
Discrete-time simulation is used, meaning an agent accelerates at a fixed rate
for the duration of a ``tick'' (also referred to as ``step'') to achieve a new
position and velocity. The tick duration $dt$ is configurable and fixed for the
simulation. Agents know this value and use it to reason about collision
avoidance and satisfying other constraints, so setting this value to the
standard ``reaction time'' of a human driver may be appropriate. Each tick, the
simulation performs the following steps:

\begin{enumerate}
  \item Introducing new agents into the map
  \item Updating the position and velocity of agents
  \item Checking for collisions
  \item Allowing each agent to react
\end{enumerate}

Agents have few enforced constraints -- they cannot exceed their physical
acceleration capabilities, travel in reverse, or travel past the end of a
traversable without appearing on the next. Intersection policies and avoiding
collisions on the same edge are the source of the other constraint in the
simulation, but it is the job of a behavior to obey. There are three main
components of the simulation, each configurable by extending default classes:
agent behaviors, routing strategies, and intersection policies. Each will be
described below.


justify arbitrary constants, like deaccel for cars

scale

systems ideas, or limitations.. trylocks, atomic sim update, deadlock issues

limit: no lane-changing

\subsection{Spawning}

in realtime, safely!

and architecture review (generators and thread pool)

\subsection{Collision checking}

There are two structures to detect collisions. All traversables (edges and the
straight line-approximation of turns) maintain a queue of occupying agents,
ordering them so that the agent farthest along is at the head of the queue.
A naive method of collision detection would detect an agent passing an agent on
the same queue, or entering a new queue not at the end, immediately after an
agent moves. However, agents take their steps sequentially and in an effectively
random order. Ideally they could be reordered so that agents in the front of a
queue always move first. Since the first agent may cross into the next queue,
that introduces a depdendency between traversables. A topological sort of a
directed graph containing circuits is not possible, though, and since we
guarantee connectedness, there are obviously circuits. Instead, collisions are
checked after every agent has stepped forward in time, guaranteeing that a
time-step is atomic. Queues remember the original order of agents before a step,
and afterwards can verify the order is still legal, with new agents on the end
and existing agents in the same order.  Likewise, intersections check for
collisions after everybody has moved by examining the turn each agent is
performing and verifying that no other agent is simultaneously performing a
conflicting turn.

\section{Agent Reactions}

Each agent has a ``behavior'' governing it. When the agent travels past the end
of an edge during its step, the behavior picks the turn to pursue. Each tick,
the behavior can make the agent react by performing one of two actions:
disappearing from the map (only when the agent is at rest and is done with its
route) or setting an acceleration for the next step. In the future, another
possible action will be initiating a lane-change or merge.

Currently, the primary behavior used by all agents is the ``route-following
behavior.'' It is a generalized, baseline behavior that guarantees not to
collide with another agent or enter an intersection at the wrong time. It avoids
some forms of deadlock (in which no agent can move due to interdependencies),
but there is currently one known flaw. This baseline behavior picks the fasrest
conservative (safe) choice of acceleration at each step. It could be easily
extended to mimic human drivers by introducing a higher reaction time delay, for
instance, or tune rates of acceleration for optimizing fuel efficiency.

Since agents know the fixed $dt$ duration, they may reason about what could
happen during the next tick and avoid collision and illegal intersection entry.
The conservative analysis is to determine worst case -- how far could an agent
travel by the end of the next tick? If they accelerate as fast as possible for
$dt$, this gives them the longest possible traveling distance and highest
possible speed. Adding the stopping distance for this speed to the traveling
distance gives the worst-case distance.
\commentd{how much formula? pretty simple so far, but can certainly include them.
 should this part be worded like a proof? (because it can be)}

The worst-case distance may exceed the distance remaining on the agent's current
traversable. That means they could start or finish a turn during the next tick.
Because edges are often extremely short (less than $???$ meters), they may
travel through several traversables during the next move. Thus, any conservative
behavior must look ahead until the worst-case distance is exhausted, asking the
route strategy which turn an agent will choose in the future. At each
traversable considered, there are 3 constraints to satisfy: obeying the
intersection, avoiding collision with another agent, and obeying speed limits.
Each constraint contributes the max acceleration that will obey the limit, so
ultimately the result of lookahead will be the minimum of these candidates.

A behavior's interaction with an intersection policy amounts to polling it with
the turn the agent wants to perform, the distance along the incoming edge the
agent will be, and how long the agent has been waiting (so policies can enforce
a required delay before entering the intersection). The intersection policy
simply orders the agent to ``stop'' or ``continue.'' The lookahead considers no
intersections beyond the first that issues ``stop'', since the behavior cannot
legally proceed past that one anyway.  The acceleration to avoid entering an
intersection attempts to end a configurable threshold back from the end of a
traversable to account for crosswalks and as an epsilon value, since achieveing
a distance along an edge equal to its length means spilling over into the next
traversable, which the intersection has banned. Sometimes stopping behind this
threshold is not possible -- namely, when the edge length is shorter -- and in
that case, anywhere before the end is acceptable.
\commentd{include some form of piyush's proof about accel to end?}

When the lookahead analysis is considering some future traversable, it only has
to consider the agent closest to the start in the present. An edge may only be
entered from a turn, so the intersection policy has the burden of ensuring no
agent performs a turn that leads to the same edge simultaneously. Following an
agent safely means maintaining a configurable following distance behind the
agent. Worst-case analysis is again used: the most dangerous move the agent in
front could perform is decelerating as fast as possible the next tick, and the
worst-case traveling distance for the agent behind is already known from
lookahead. Maintaining following distance from agents actually enables a form of
deadlock in the simulation. If an agent is forced to stop in an intersection
mid-turn due to its destination edge filling up with other agents, then nobody
may cross the blocked intersection. With many agents in a small area, this
situation may occur several times in an interdependent way. The solution
currently being investigated will require behaviors to ensure a turn may be
fully completed before starting it. This will prevent intersections from ever
being blocked.
\commentd{diagram showing deadlock}
\commentd{i really hope to fix this issue soon, but it's not an immediately easy
fix}

Finally, obeying a road's speed limit is a simple constraint. Like many
parameters of the map, speed limits are inferred from the road type claimed by
the OSM source.

\commentd{diagram for example of lookahead?}

\commentd{mention epsilon issues?}

\section{Routing Strategies}

Picking accelerations that optimize some objective functions is a separate task
from picking a path to travel. Thus, the behavior described above can consult
any route strategy. Currently two simple implementations are available. One
statically plans a route to some goal using standard the A* search; the other
performs a drunken walk, making random choices at each intersection. The latter
lazily plans several steps ahead, only when the behavior's lookahead engine
needs to know. Future experiments in dynamic replanning or hierarchial planning
can be performed without modifying any code other than a creating new route
implementation.

\section{Intersection Policies}

when is an agent waiting?

and future plans

\section{Determinism and other simulation properties}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{EXPERIMENTAL RESULTS}

% upgrading stop signs to signals, optimizing timing

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{CONCLUSIONS}

Write me.

\addtolength{\textheight}{-12cm}  % This command serves to balance the column lengths
                                  % on the last page of the document manually. It shortens
                                  % the textheight of the last page by a suitable amount.
                                  % This command does not take effect until the next page
                                  % so it should come on the page before the last. Make
                                  % sure that you do not shorten the textheight too much.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{APPENDIX}

Probably stuff about getting and using the code.

\section*{ACKNOWLEDGMENT}

Dr. Quinlan has certainly been helpful.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Notes.

%possible background/links

%http://www.caliper.com/transmodeler/default.htm
%http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6082793
%https://www.google.com/search?sourceid=chrome&ie=UTF-8&q=Agent-Based+Traffic+Simulation+and+Traffic+Signal+Timing+Optimization+with+GPU

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{thebibliography}{99}

\bibitem{c1} G. O. Young, ÒSynthetic structure of industrial plastics (Book style with paper title and editor),Ó 	in Plastics, 2nd ed. vol. 3, J. Peters, Ed.  New York: McGraw-Hill, 1964, pp. 15Ð64.
\end{thebibliography}

\end{document}

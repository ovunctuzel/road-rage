\documentclass[letterpaper, 10 pt, conference]{ieeeconf}  % Comment this line out
                                                          % if you need a4paper
%\documentclass[a4paper, 10pt, conference]{ieeeconf}      % Use this line for a4
                                                          % paper

\IEEEoverridecommandlockouts                              % This command is only
                                                          % needed if you want to
                                                          % use the \thanks command
\overrideIEEEmargins
% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document

\title{\LARGE \bf
TODO Name this thing
}

% TODO which style do we use for authors? and do we list all 4 of us here?

%\author{ \parbox{3 in}{\centering Huibert Kwakernaak*
%         \thanks{*Use the $\backslash$thanks command to put information here}\\
%         Faculty of Electrical Engineering, Mathematics and Computer Science\\
%         University of Twente\\
%         7500 AE Enschede, The Netherlands\\
%         {\tt\small h.kwakernaak@autsubmit.com}}
%         \hspace*{ 0.5 in}
%         \parbox{3 in}{ \centering Pradeep Misra**
%         \thanks{**The footnote marks may be inserted manually}\\
%        Department of Electrical Engineering \\
%         Wright State University\\
%         Dayton, OH 45435, USA\\
%         {\tt\small pmisra@cs.wright.edu}}
%}

\author{Huibert Kwakernaak$^{1}$ and Pradeep Misra$^{2}$% <-this % stops a space
% \thanks{$^{1}$H. Kwakernaak is with Faculty of Electrical Engineering, Mathematics and Computer Science,
%         University of Twente, 7500 AE Enschede, The Netherlands
%         {\tt\small h.kwakernaak at papercept.net}}%
% \thanks{$^{2}$P. Misra is with the Department of Electrical Engineering, Wright State University,
%         Dayton, OH 45435, USA
%         {\tt\small p.misra at ieee.org}}%
}

\long\def\commentp#1{{\bf **Peter: #1**}}
\long\def\commentpk#1{{\bf **Piyush: #1**}}
\long\def\commentm#1{{\bf **Mike: #1**}}
\long\def\commentd#1{{\bf **Dustin: #1**}}

\begin{document}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
Write this.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{INTRODUCTION}

\commentpk{This section is still under construction. Do not review.}

% what are our goals with this paper?
% theme: easy simulation in your city, in 2 minutes!
% * demonstrate use of OSM and motivate more data collection
% * present a simulation framework
% * present a pretty naive static planning
% * motivate and demonstrate wards for hierarchial planning (but also reasoning
%    about congestion)
% be sure to emphasize open source!

% contribution: autonomous car / human car sim on EXISTING INFRASTRUCTURE

Autonomous vehicles have seen tremendous progress in recent years. In 2004, no autonomous vehicle was able to complete the course set out in the first DARPA Challenge. By 2007, 5 vehicles finished the course of 130 miles in urban environments. By 2011, autonomous vehicles projects have now touched 160,000 miles and an autonomous car drove for 13,000 miles in Europe. Autonomous cars are here to stay, and this changes how traffic is dealt with in the forseeable future. The infrastructure will change to support autonomous vehicles, but it is hard to say more about our traffic demands. Will we be able to gain more roads in the future. Do we have the space to expand and will autonomous vehicles be able to reach your doorstep.

This paper presents a new methodology for micro-simulating autonomous traffic for such situations where we will continue to use existing roads for autonomous vehicles. We believe that the autonomous traffic will be controlled via an overseer. The overseer can define behaviors for indivudal agents and individual intersections. The overseer itself can be a centralized and decentralized system that is capable for making such decisions in real-time.

To implement such a methodology, we have come up with our own traffic simulator called AORTA. In AORTA we focus on the behavior of agents and intersections. Our simulator is generic enough to take advantage of implementing behaviors for cars which can represent human driving, along with standardized traffic light signals. We believe that that traffic light signals will be able to do better once we start using Autonomous Intersection Managers such as AIM.

To use road data, we can use OpenStreetMap. xml files exported using OSM are directly read by a tool and parsed to create an understandable map. Our simulator then uses this map to create the simulation and can introduce an army of agents to simulate traffic inside the simulator.

\commentpk{Needs introduction to the rest of the paper here}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{RELATED WORKS}

\commentpk{This section is still under construction. Do not review.}

A number of good micro-simulators have been created in the past decade. In this section we compare some of the similarities and differences with other such simulators.

One such 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{ARCHITECTURE}

AORTA's implementation uses Scala, a language implemented on the Java Virtual
Machine. Scala provides the advantage of functional programming constructs
without imposing them; parts of AORTA or extensions or clients can just as
easily be written in the more familiar Java.

The architecture of AORTA is described below.

thread pools?

programs: build map, UI (describe what it can do), headless

api / extending it
maps separate from simulation separate from UI (mostly)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{MAP CONSTRUCTION FROM OSM}

% TODO briefly introduce OSM, advantages, etc

To run a simulation on a map from OSM, there is a one-time conversion process to
transform the map into AORTA's format, which is also encoded with XML. It is
split into 3 passes, each feeding the next.

\subsection{Map Model}

roads, verts, edges, wards, traversables, turns...

edges are made up of multiple lines.. this could be control pts of a curve
(hereon, line means line segment)
(turns are also traversable)

\subsection{Pass 1}

The relevant parts of OSM's map model are nodes and ways. A node corresponds to
a GPS location, and ways are links between many nodes, corresponding to roads
and other paths. The first pass reads OSM's XML format, gathering ways as a
series of coordinates. Ways intersect when a node is used by multiple ways.

Since OSM also encodes pedestrian paths, bike routes, and even lakes with ways,
pass 1 filters out anything that does not seem to be driveable. OSM does not
seem to provide a unified list of valid roads, so these heuristics are
imperfect.

Finally, coordinates are normalized from GPS (longitude, latitude) to a planar
coordinate system with no negative coordinates and the Y coordinate increasing
upwards. This is done for convenince of manipulation in the UI, but the scale
and offset used are retained, so a coordinate in the final form of the map can
still be mapped back to its original GPS form.

\subsection{Pass 2}

OSM ways only implicitly intersect at common coordinates; AORTA's structure
demands a traditional definition of edge linking exactly two vertices. Pass 2
walks along each way's coordinates, dividing it into multiple undirected edges.

\subsection{Pass 3}

Finally, pass 3 performs successive transformations to produce the final graph,
which is saved in XML.

\subsubsection{Making Lanes}

Undirected edges are first multiplied into directed lanes. The coordinates from
a slice of an OSM way are interpreted to be the center line of the road, and
lanes are placed by projecting the width of a line perpendicularly from the
center line in either direction. OSM encodes one-way streets, so in this case,
if there are an odd number of one-way lanes, the middle lane is placed where the
center line would be, and the other lanes are shifted from there. If there are
an even number, then the middle two are both equidistant away from the invisible
center line. The number of lanes is guessed from OSM's annotation of the way's
``type.'' OSM's specification includes a tag for number of lanes, but in
practice as of the time of writing, it is rarely used.

\subsubsection{Making Turns}

Next, turns are constructed at each vertex between the incoming and outgoing
edges. This is completely heuristic based: we classify a potential turn as a
left, right, or straight turn based solely on angles between edges and if the
edge's original OSM ID matches. U-turns are constructed at dead-ends. If several
lanes all cross into fewer lanes, merging is forced for the rightmost lanes.
These patterns are attempts at generalizations; this process results in many
intersections having the incorrect turns. However, without a more detailed
source, this is the best compromise. Finally, the geometry of a turn is
extremely simplified as a single line between the ends of the edges it connects.
In the future, a more realistic curve could be drawn.

\subsubsection{Ensuring connectivity}

Because turns are constructed imperfectly, most large graphs have edges that are
not reachable from some portions of the graph. Simulation and pathfinding would
suffer greatly if this was the case, so pass 3 uses Tarjan's linear-time
algorithm for locating strongly connected components to remove the components of
the directed graph with the least members. (There is also a debugging switch to
leave these components in and highlight them in the UI.) The algorithm operates
at the granularity of lanes. If several lanes of many are disconnected within
one road, then the bad lanes are spliced out. This results in visually
unappealing geometric gaps, but if the entire road were removed, then Tarjan's
algorithm would have to be repeated to determine what edges the good lanes would
then disconnect. The end result is a connected digraph, ideal for corner
case-free pathfinding and simulation.

\subsubsection{Cleaning up geometry}

A road's center line correctly meets adjoining roads' center lines in the middle
of an intersection. Since the lines for a lane are parallel to the center line
and have the same length, they also meet in the intersection. This is
geometrically incorrect; lanes stop along the border of the intersection. Thus,
pass 3 includes heuristics to trim a lane's lines to the spot where they
intersect with another lane's lines. This results in a more accurate model, but
the process is imperfect, so sometimes lines extend too far or not enough.

\subsubsection{Hierarchial divisions of the graph}

% TODO i don't think this'll have much coverage in the rest of the paper; should
% we describe wards?

\subsection{Limitations}

proposals to change OSM to fix these issues

projecting lines sucks... but all it really does is clutter UI
filtering out invalid ways in pass 1 is really not a clear process
number of lanes... road types are wacky and wrong
turns are brittle.. detecting right-turn only lane is rare. shared center lane?
  not part of our model, or OSM's.
removing sccs is not ideal

\subsection{Integrating other data sources}

how easy would it be?

match on gps, or on road metadata like names

integrating with what other sources for spawning traffic, placing POI?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{SIMULATION}

AORTA uses microscopic simulation, modeling individual drivers as agents.
Discrete-time simulation is used, meaning an agent accelerates at a fixed rate
for the duration of a ``tick'' to achieve a new position and velocity. The tick
duration $dt$ is configurable and fixed for the simulation. Agents know this
value and use it to reason about collision avoidance and satisfying other
constraints, so setting this value to the standard ``reaction time'' of a human
driver may be appropriate. Each tick, the simulation performs the following
steps:
\begin{enumerate}
  \item Introducing new agents into the map
  \item Updating the position and velocity of agents
  \item Checking for collisions
  \item Allowing each agent to react
\end{enumerate}

Agents have few enforced constraints -- they cannot exceed their physical
acceleration capabilities, travel in reverse, or travel past the end of a
traversable without appearing on the next. Intersection policies and avoiding
collisions on the same edge are the source of the other constraint in the
simulation, but it is the job of a behavior to obey. There are three main
components of the simulation, each configurable by extending default classes:
agent behaviors, routing strategies, and intersection policies. Each will be
described below.


justify arbitrary constants, like deaccel for cars

scale

systems ideas, or limitations.. trylocks, atomic sim update, deadlock issues

limit: no lane-changing

\subsection{Spawning}

in realtime!

\subsection{Collision checking}

There are two structures to detect collisions. All traversables (edges and the
straight line-approximation of turns) maintain a queue of occupying agents,
ordering them so that the agent farthest along is at the head of the queue.
A naive method of collision detection would detect an agent passing an agent on
the same queue, or entering a new queue not at the end, immediately after an
agent moves. However, agents take their steps sequentially and in an effectively
random order. Ideally they could be reordered so that agents in the front of a
queue always move first. Since the first agent may cross into the next queue,
that introduces a depdendency between traversables. A topological sort of a
directed graph containing circuits is not possible, though, and since we
guarantee connectedness, there are obviously circuits. Instead, collisions are
checked after every agent has stepped forward in time, guaranteeing that a
time-step is atomic. Queues remember the original order of agents before a step,
and afterwards can verify the order is still legal, with new agents on the end
and existing agents in the same order.  Likewise, intersections check for
collisions after everybody has moved by examining the turn each agent is
performing and verifying that no other agent is simultaneously performing a
conflicting turn.

\section*{Agent Reactions}

Each agent has a ``behavior'' governing it. When the agent travels past the end
of an edge during its step, the behavior picks the turn to pursue. Each tick,
the behavior can make the agent react by performing one of two actions:
disappearing from the map (only when the agent is at rest and is done with its
route) or setting an acceleration for the next step. In the future, another
possible action will be initiating a lane-change or merge.

Currently, the primary behavior used by all agents is the ``route-following
behavior.'' It is a generalized, baseline behavior that guarantees not to
collide with another agent or enter an intersection at the wrong time. It avoids
some forms of deadlock (in which no agent can move due to interdependencies),
but there is currently one known flaw. This baseline behavior picks the fasrest
conservative (safe) choice of acceleration at each step. It could be easily
extended to mimic human drivers by introducing a higher reaction time delay, for
instance.

% TODO diagram for lookahead

lookahead... worst-case stop dist argument is everywhere.

\section*{Routing Strategies}

\section*{Intersection Policies}

and future plans

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{EXPERIMENTAL RESULTS}

% upgrading stop signs to signals, optimizing timing

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{CONCLUSIONS}

Write me.

\addtolength{\textheight}{-12cm}  % This command serves to balance the column lengths
                                  % on the last page of the document manually. It shortens
                                  % the textheight of the last page by a suitable amount.
                                  % This command does not take effect until the next page
                                  % so it should come on the page before the last. Make
                                  % sure that you do not shorten the textheight too much.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{APPENDIX}

Probably stuff about getting and using the code.

\section*{ACKNOWLEDGMENT}

Dr. Quinlan has certainly been helpful.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Notes.

%possible background/links

%http://www.caliper.com/transmodeler/default.htm
%http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6082793
%https://www.google.com/search?sourceid=chrome&ie=UTF-8&q=Agent-Based+Traffic+Simulation+and+Traffic+Signal+Timing+Optimization+with+GPU

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{thebibliography}{99}

\bibitem{c1} G. O. Young, ÒSynthetic structure of industrial plastics (Book style with paper title and editor),Ó 	in Plastics, 2nd ed. vol. 3, J. Peters, Ed.  New York: McGraw-Hill, 1964, pp. 15Ð64.
\end{thebibliography}

\end{document}
